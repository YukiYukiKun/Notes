参考教材 theory.stanford.edu/~amitp/GameProgramming/index.html

# A*
是在图上的搜索方法，使用的时候都需要把地图变成格子。
实际上就是 Dijkstra 算法的流程，在计算花费时加上了启发函数 H() 的值。

- 启发函数值大小
    启发函数给的预估值相对于最终真实距离越大，搜索就越快。但当其大于真实距离时，算法将不保证找到最优解。而小于或等于真实距离时都是保证找到最优解的，虽然会很慢。
- 启发函数类型
    简单的 L2 L1 范数都可以。或者随便用个什么更高级的。
- 等值问题
    想下 Dijkstra 需要取出花费最小的目标作为下一步，出现等值的花费的情况会导致多余的探索。我们可以给启发函数增加扰动以避免这种情况。若乘以增大的系数，将使我们更倾向于靠近终点的探索；乘以缩小系数则反之（虽然我不知道为什么）。显然我们只会使用**增大的系数**。
- 实际应用
    A* 只是一个抽象的算法，所有的寻路都是以这个为基础的，只是对地图的表示不一样（Way Point 或 Navi Mesh）

# 地图表示 - Way Point
将地图表示为点和边的形式进行寻路。算法大概为以下步骤：
1. 制作好地图后，需要地图中标出 Way Point，需要确保地图中每一个角落都能直接看见至少一个 Way Point。当然也需要避免过多过密。
2. 出发时找到离起点和终点最近的两个点，作为算法的起点和终点。
3. 直接利用 A* 的算法寻路。如果 Way Point 设置得当将会非常快。
4. 先走到起点，再根据寻路算法得到的路径走，最后再走去终点。

问题和优化
- Way Point 太难标好了！
    工作量大，而且也很难标出高质量。可以尝试 AI 算法生成，并加上一些（如是否全部可达的）检查保证质量。
- 容易走 Z 型
    点的密度很低，很容易走出 Z 型。可以移除路径中可以直接行走的两点之间的中间点，使得路径平滑。
- 走近处很奇怪
    如果只按照前述算法，走近处会表现的很奇怪。可以修改算法，如果终点是能直接走到的则不再寻路。
- 地形变化咋办
    凉拌

# 地图表示 - Mesh
将地图表示为凸多边形（通常是四边形格子）进行寻路。
分割格子后，可以选择以格子的 **中心点 角 边上的若干点** 作为图的节点，一般混合使用。
实际上，相当于以一种比较密集的方式划分了点。这样走起来通常比 Way Point 更加平滑。

Mesh 方式同样可以使用在 Way Point 中提到的 “移除中间节点” 平滑手段，处理后只会剩下拐角的节点。如此做之后，我们在寻路时可以只计算网格角上的点。

# 层次结构
分层进行寻路。如将整个地图切分为大格子，以大格子为单位建立一张图进行近似寻路。在格子内用最细的那张图寻路，到达格子边缘后用粗略的图寻路。
在高层次（城市之间）进行寻路时开销肯定更小，因为高层次的图细节更少了。当然也许不是严格的最优解，但是也不会差太远。

# 多单位移动
一组单位一同寻路时，增加适当偏移。或挑选一个 leader，使用 steering behavior 控制整体移动。
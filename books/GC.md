注意概念：写入屏障。指在进行指针指向操作时需要额外完成的操作。在 GC 中相当常见。

Mark Sweep
===
- **概述**
    - 可直接在对象头部 mark。
    - 需要维护空闲链表。
    - 可以合并连续小块。

- **优点**
    - 实现简单。
    - 与保守式 GC 兼容。

- **问题**
    - 碎片化。
    - 分配需要通过空闲链表，慢。
    - 标记时要修改对象本身，影响 copy-on-write。

- **改进**
    - 空闲链表按照大小分类。如此快速找到合适的块。
    - 位图表格：标记在一张集中的 bitmap 中进行。通常一个字一个位，只需要标记对象起始的那个字对应的位。
    - 延迟清除：分配时尝试执行（一部分）清除，没找到就补充一些标记再清除。

Reference Counting
===
- **概述**
    - 计数也在对象头。
    - 不显式启动 GC，而是在发现引用清0时立即执行。注意这里很容易出现一串链式回收。

- **优点**
    - 快，（几乎）没暂停。
    - 回收时不需要沿根查找。

- **问题**
    - 为了确保正确，计数器需要占很多位。
    - 实现很难，修改指针的地方都要有逻辑。
    - 循环引用，无解。

- **部分标记清除**
    用于处理循环引用。
    算法太鸡儿麻烦了，总之就是只尝试 mark 可能是循环垃圾的对象。

Copy
===
- **概述**
    - 是在 from 和 to 空间进行的。

- **优点**
    - 吞吐量优秀，尤其是存活对象少时（也是大多数情况，尤其是在新生代）。
    - 无碎片。因此分配飞快，只需要推指针。
    - 复制时的流程可以把互相引用的对象放在一起，即根据引用链复制。如此对缓存更友好（空间局部性）。

- **问题**
    - 需要两块空间。
    - 不与保守式 GC 兼容。

Mark Compact
===
这里咱只介绍 Lisp2 算法。
- **流程**
    1. 标记后，计算好每个对象压缩后的新位置，存在对象里。
    2. 修改所有引用，指向新位置。
    3. 从前往后扫依次移动。

    虽然堆利用率高，但是需要扫和计算三次，比较慢。

保守式 GC
===
知道有这个就好啦，主要是应对一串数字不确定是不是指针的情况，毕竟编译过后就丢失所有类型信息了。

分代
===
- **记录集**
    由于新生代会独立于老生代乱变，所以引入记录集，记录所有对新生代有引用的老生代对象。
    一方面 ygc 时可以快速统计来自老生代的引用；一方面收拾新生代时，遍历记录集即可快速更新老生代的指针。

- **卡表**
    和记录集合一样的功能，用位图标识对新生代对象有引用的老年对象的位置。一般一位代表 128B。

- **火车算法**
    不看惹！效果是可以让空闲的和非空闲的分开。

增量回收
===
渐进回收，用吞吐量换短停顿。负担主要是写入屏障和反复的标记造成的。
不过其实这里的渐进回收只有标记阶段，和 CMS 是一个感觉。

- **三色标记**
    颜色有以下三种：
    - 白：未搜索过，可能是没标记到或的确没有引用。
    - 灰：正在搜索，即自己的孩子还没有被搜索玩。
    - 黑：搜索完成，一条引用链全部标记完。GC 完成时，全部对象要么是黑色，要么是白色。

    算法步骤为：
    1. 和根直接相连的对象全部标灰色。
    2. 找所有现有灰色对象继续往下做标记。这一步可以并行做，一次做一点。
    3. 注意，此时所有的指针改变，若新指向的对象是白色，都应将其标记为灰色以避免遗漏。
    4. 也许需要一个 final remark，stw 消除所有剩余的灰色。
    5. 清除所有白色对象。

内存分配与回收的实现
===
内存分配参考你的 netty 笔记。
Python 的回收随便看看就好。
这本书已经很熟了，这里只记录一些遗忘的要点

概述
===
- **生成可运行文件流程**
    源码 **.c** -> 中间代码 **.i** -> 汇编代码 **.s** -> 单文件二进制 **.o** -> 连接后的应用或 **.so**

- **系统结构**
    需要注意，系统总线和 IO 总线、主存总线是分开的。它们通过 IO 桥相连。
    DMA 可以将 IO 数据直接送入主存。

信息的表示和处理
===
- **大小端**
    留意 Java 里是大端，网络中通常也是大端。Intel 中是小端。

- **逻辑运算**
    满足交换律结合律。
    或 0 后不会变。且 1 后不会变。
    自己异或自己是 0，异或 0 后不变，异或 1 取反。
    交换 a b 变量可以用 a=a^b b=a^b a=a^b。根据上面的前两条规则悟一下。

- **位移**
    逻辑右移补 0，算数右移补最高位。左移一律补 0。

- **浮点数**
    二进制小数，小数点部分的长度是**分母**，二进制原码数值是**分子**。
    尾数是一个全为小数部分的二进制小数，剩余部分是符号位和可正可负的阶码。而浮点数的值是 **尾数 * (2 ^ 阶码)**。看起来相当于阶码移动了小数点。

程序的机器级表示
===
- **架构名**
    IA32 也就是 x86。x86-64 是在其基础上的 64 位指令集。IA64 是 intel 的新 64 位指令集。
    但 AMD64 是现在最常用的。

- **IA32 基本组成**
    - PC
    - 整数寄存器
    - 浮点数寄存器
    - 条件寄存器

    虽然是废话，代码本身也是有地址的。
    注意，汇编代码在汇编阶段都是使用的变量名，因为在连接之前地址都不确定。

- **链接**
    将参与编译的 **.o** 组合起来，确定变量的地址。还把代码挪在了一起，因此地址和汇编前不同。

- **操作数分类**
    - 立即数
    - 寄存器变量
    - 主存变量，附带一堆乱七八糟的寻址。

- **逻辑流**
    在有条件和循环，或发生函数调用时，修改 PC 的值。平时就直接 +1。

- **栈操作**
    栈向下增长。
    栈帧追加时，原寄存器和 PC 由函数调用栈帧和新栈帧一人存一部分。参数和返回值可以用寄存器传，也可以根据规则排在栈里。
    **注意，操作栈也是在操作主存，所以你从堆里面取东西放进栈，必须有 堆->寄存器->栈 两步**。

- **基于栈和基于寄存器的指令集**
    除了函数调用时传参的方式，指令传参也会不同。
    汇编指令的参数都在寄存器。在虚拟机的抽象中，有的在寄存器有的在栈（如 Hotspot）。
    栈指令消耗的指令数更多传参时有一堆压栈出栈操作，不过指令种类更少，跨平台能力也更好。

- **条件传送指令**
    因为大多数时候走到分支时并不知道到底走哪边（还需要其他计算结果），为避免分支预测失败让流水线抛弃一大堆算好的结果，可以选择同时走俩分支。

处理器体系结构
===
- **处理器干活阶段**
    1. 取指：根据 PC 取出指令。
    2. 译码：从寄存器或者栈里读好参数。
    3. 执行：干活。
    4. 访存：输出一些影响内存的副作用。
    5. 写回：输出结果到寄存器或者栈里。

存储器
===
- **内存**
    - SRAM 牛逼的那个，用在 cache 和 register。
    - DRAM 菜的那个，用在主存。需要不断刷新。
    - ROM 掉电不会消失的，闪存
    注意，存储都以块为单位，一次 32b 或 64。

- **内存访问**
    通过总线进行通信。**读事务** 和 **写事务** 皆由 IO 桥转发。也就是 IO 桥分辨总线上的消息是给主存还是 IO 的，然后决定送给 **IO 总线**还是**内存总线**。

- **磁盘访问**
    提醒一下，磁道指的是一圈。需要先找到**磁道**再找到**扇区**。
    读取由扇区为单位，就是你熟悉的磁盘块。通常是 512B 或者 1kB 的亚子。
    再次强调，寻道和旋转的时间占了访问的 **99%** 以上。

- **DMA**
    **磁盘直接送到主存**，这叫DMA传送。完成后将触发 CPU 硬件中断。

- **局部性**
    - 空间：读到的东西地址相近的部分，更容易在未来用到。如，同一个对象的若干字段。
    - 时间：读到的东西本身，更容易在未来再次用到。如，循环中使用的数据和代码。

- **缓存体系**
    每一层之间以块为单位进行缓存。**离 CPU 越远，块越大。**好不容易取一次，就多取点吧！

- **驱逐算法**
    主要有 **LRU** 和 *
    - **LRU** 记最近被用到的时间，最久的淘汰。搞个 LinkedHashMap 就可以 O(1)。
    - **LFU** 记最近使用次数，最低的淘汰。

- **缓存映射**
    - 全相联
    - 直接相连
    - 组相联
    用奶子想就知道，离 CPU 越远就越接近全相联，因为 miss 的代价已经大大超过了调度的花费。

- **不命中类型**
    - 冲突不命中 同组或直接相连时，因为冲突而互相顶。此时可能有其他空块。
    - 容量不命中 就是缓存太小。

- **缓存对局部性的应用**
    - 时间局部 缓存的数据，也许会被读多次。
    - 空间局部 同块一起缓存的数据，也许未来会用到。

- **写策略**
    写入时机策略
    - 直写 直接往下一层缓存写。
    - 写回 等到驱逐时在写。减少了总线流量，增加了调度消耗（需要记录脏）。

    写不命中策略
    - 非写分配 直接跳过没有的缓存。通常和直写一起用。大概是因为直写比较频繁，写分配压力大。
    - 写分配 先分配进前一层缓存，再写入。通常和写回一起用。

- **缓存参数影响**
    - 缓存越大，命中率越高，但命中时间越长。除了对 L1 以外，其他地方都是越大越好。
    - 块越大，越能利用空间局部性，但命中率下降（因为块数降低了）。
    - 相联度越高，命中率越高，命中调度时间越长。离 CPU 越远，优点越明显。
    - 写策略，离 CPU 越远越倾向于用写回。因为直写的频繁传送对于远的设备开销很大。

- **局部性利用**
    这里留意多维数组，应每次按行走。因为行是一整块接近的内存。

链接
===
- **ELF头**
    - .text 机器代码 （代码段）
    - .rodata 只读代码，如 swwitch 的跳转表 （代码段）
    - .data 已初始化的全局变量 （读写段）
    - .bss 为初始化的全局变量，这里只有声明，单独放为了省空间。 （读写段）
    - .symtab 符号表，用来索引全局变量和函数（名字->地址？）
    - .rel.text 指出 .text 中条目的位置。**链接后重写并消失。**
    - .rel.data 指出 .data 中条目的位置。**链接后重写并消失。**
    - .debug 变量定义信息，名字啥的。用于 debug。
    - .line .text 中机器代码和本文件中行号的关系。

    注意，链接完成后的文件还会有 entrypoint，即 PC 的第一条指令。

- **符号解析**
    变量函数名字转换为地址。
    自己文件里的可以在编译时搞定，外界的必须链接。

- **链接分类**
    - **静态链接** 链接时直接结合多个可重定向文件或库，生出一坨解析好的可执行文件。注意，使用库可以避免参与链接的多个文件重复引用库。
    - **动态链接** 启动加载时或运行跑到时，在把 .so 或者 .dll 读取解析。运行时的例子有 JNI。

- **可执行文件加载**
    地址由高到低分别是
    - 内核空间
    - 栈，向下增长
    - 共享库存储器映射，从某个固定地址向上增长
    - 堆，向上增长
    - 读写段
    - 只读段

注意，加载完成后，中间的未分配空洞其实并没有分配内存。运行时通过缺页中断补足。

异常控制流
===
- **概述**
    **异常（Exception）**是对中断陷阱等的统称。一部分由硬件实现（硬中断），一部分由 OS 实现（软中断）。CPU发现有异常时，将用一张**异常处理程序**表来处理，它的 key 为异常号。。
    可能与当前指令有关（出错了），也可能无关（IO 事件，定时器）。
    关于 PC，**在处理程序完成后**，可能返回给当前指令，可能执行下一条指令，也可能直接把程序关了。

- **分类**
    - **中断 interrupt**
        来自**外界**的 IO 信号。由硬件引发，信号送到 CPU 的引脚上，具体异常号放在总线上。处理结束后执行之前的下一条指令。

    - **软中断**
        对前述中断的特殊处理。为了确保所有中断都能快速返回，耗时的中断处理程序将直接完成，并使用软中断异步继续完成。
        也就是说 **硬件中断处理服务程序对内核的中断。**
        对应系统调用 **INT**。

    - **陷阱 trap**
        **自己主动的**，是为了系统调用。处理（系统调用）结束后执行之前的下一条指令。Unix 中，**使用软中断 INT 80**。

    - **故障 fault**
        **自己引发的**。可以修复的（如缺页故障）。处理完成后返回之前的当条指令，不可修复的程序终止。

    - **终止 abort**
        **自己引发的。**修不好的错，程序直接没了。如硬件故障。

    - **信号 signal**
        Unix实现的，**用户和系统都可以发。** 比起前述层级更高。信号也需要处理程序，执行完成后继续下一条指令。不覆盖处理程序则进程死掉。


    - （特殊）上下文切换
        1. 操作系统引发的一种异常。用于抢占式调度，或换出等待IO的线程。实现是在操作系统层面。
        2. 中断引起上下文切换：大多数系统会有定时器，根据时钟信号触发中断，并在此时决定调度和上下文切换。
        **注意，并不是切换到内核态必然发生上下文切换，而是系统调用通常带有IO，容易引起切换**

        **开销：**注意，除了存储和恢复上下文的情况，上下文切换还会污染缓存。

- **内核模式**
    在高位的内核区，也和用户区一样有 代码 数据 堆 栈。比如因为 trap 切回内核区了，程序在内核区继续进行。

虚拟存储器
===
将主存看作磁盘的 cache，当然内容是前面提到的进程空间。
为每个进程提供一致的空间，包含结构和地址。

- **页 page**
    虚拟内存的基本单位。以页为单位和真内存里的页相对应。当然，真内存里的页位置都无所谓。
    虚拟内存中，页可能未初始化，可能有了对应的物理内存，也可能被再次换出。

    由于内存再不命中，代价就极大了。所以根据前述原则，使用相对大的页（4kB-2mB），且使用全相联。**MySQL的节点大小应该也是参考这里**。

- **页表**
    记录虚拟内存中每一页对应物理内存或磁盘的哪里。

- **缺页**
    触发缺页故障。走前述异常处理流程。也就是异常处理完成后，重新读一次页就有了。

- **mmap**
    将磁盘和虚拟页面联系起来。可以映射磁盘里的文件，以用操作内存的方式操作它；或使用 mmap 来进行进程间通信。
    还涉及到 copyOnWrite，需要留意。

- **内存分配**
    栈里面是直接推指针。
    堆也是用系统调用推指针，但是内存分配器会做各种优化。

IO
===
- **进程FD**
    进程初始化时会打开 STDIN STDOUT STDERR 三个文件。

- **内核打开文件方式**
    共用到三个结构：
    - FD 表
        进程私有，指向文件表项。fork 时会原样 copy，且在子进程永久保留。只能在 fork 时指定 CLOEXEC 选项，或在子进程手动删除。
    - 文件 handle 表
        所有进程公用，指向 v-node 表。还包含了当前操作文件的位置。维护了引用计数。
    - v-node 表
        指向真正的文件。

- **IO重定向**
    修改了 **FD 表项**，使其指向另一个 FD 指向的文件表。

- **Linux文件简述 & 软硬连接**
    区分于上述虚拟文件系统，Linux 的文件系统顺序为 文件条目 -> i-node -> 磁盘内容 的结构。其中 inode 就代表了真文件。这里回忆一下它的结构。
    前述 v-node 可以说是 i-node 的虚拟版。
    - 硬链接：创建新文件条目，指向之前的 i-node。不可指向目录，删除原文件后无影响，因为 i-node 有引用计数。
    - 软链接：创建一个文本快捷方式，指向之前的文件条目。

- **管道和 FIFO**
    注意，这两个用于进程间通信的东西也用 FD 来表示和操作。

- **竞争**
    Linux 中，可以以独占方式打开文件；或打开时设置 O_APPEND 选项，可以避免多个进程进行追加时互相覆盖。

最后两章略了
===
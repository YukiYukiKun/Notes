概述
===

协议簇分层
---
- 链路层 Data Link Layer
    基于MAC
- 网络层 Network
    基于IP
- 传输层 Transport
    添加端口
- 应用层 Application
    不必多说

IP层路由器
---
该路由器存在于网络层，可以不关心桥接网络使用什么链路层协议，在IP这一层将不同链路层协议的网络连接。
与之相对的，交换机/网桥存在于链路层。

封装
---
如前所述，更层相当于为上层对数据完成了封装。当然，为了解析需要，本层协议头中需要标识上层协议类型。如IP层中需要表示TCP/UDP。
- TCP：Segment 段
- UDP：Datagram 数据报
- IP：Datagram 数据报
- Eternet：Frame 帧  注意，以太网帧的长度限制在1500B以内。

链路层
===
链路层主要有以下使命
- 为IP层协议传输数据
- 处理ARP/RARP

以太网 & IEEE 802
---
这两种标准有所不同。对它们的帧都有最小长度要求，以太网帧有最小长度要求，为46B。

Loopback Interface
---
向 127.0.0.1 或 localhost 发送通信。
原则上这些 Datagram 不应出现在网络上。实际上大多数实现会进行到网络层这一步，而不走链路层。
实现中，网络层/IP层中应有一环回驱动程序，离开网络层的发送给自己的数据将会直接丢进去，进入IP的接收队列。

MTU
---
所有链路层协议都有 MTU。其中，ethernet 的 MTU 为 1500B.
大于该大小的帧，必须在上层(通常是IP)进行分片处理。

两台机器通信时的 MTU 可能不是恒定的，因为链路中可能经过多个网络，它们的 MTU 各不相同，需要取最小的。
ICMP 和 IP 将会有针对 MTU 发现机制的一些处理。

网络层 IP
===
IP 是不可靠，无连接的协议。
它不保证可靠性，发生失败将直接使用 ICMP 通知；它没有连接，各个 Datagram 之间相互独立。

IP 地址
---
需要留意，实际上 IP 不是对应一台主机，而是对应主机的一个接口。
IP 地址由网络号和主机号构成。构成比例根据四类地址类型有所不同。如果主机号为0，则是一个指向网络号的IP。
注意，主机号全0代表网络号。全1代表广播。这两个都不可用作主机地址。

IP Header
---
**长度相关**
    IP 头最大可以传送 65535B 的数据，链路层会根据 MTU 为它进行分片。不过标准并没有要求主机接收超过 **576B** 的Datagram。所以大部分 UDP 相关协议都限制 Datagram 为 **512B**。不过大多数实现可以接收超过 **8192B** 的 Datagram。这大概是 TCP 的 Segment 大小可以到 1500B 的原因吧。

**TTL**
    每经过一个 router 就 -=1， 最终将被丢弃并通过 ICMP 通知。

路由
---
路由由 IP 协议负责。
IP 层遵循以下规则进行路由：目标在同一局域网则可以直接将 Datagram 丢给目标；没有在同一局域网则丢给网关（虽然 ethernet 实际上都是在做广播）。
收到 IP Datagram 后，以以下步骤进行处理：
    1. 看看是不是发给自己的，若是则自己收下了。
    2. 否则检查自己是不是 router ，如果不是则就直接无视，如果是则根据路由表进行转发。这里查表可以通过**网络号**（并配合子网掩码）来查，比起按照主机地址查，大大减小了路由表的尺寸。

子网 subnet
---
在IP地址原规则的基础上，将主机号部分再分割为子网号和主机号。
子网对于外网是透明的，即路由过来的时候只需要指定原始的网络号；但对于内网是透明的，即一个子网才是一个真正的局域网，且子网之间交流需要通过网关。
使用子网掩码进行划分，为0的位数用作主机号。

ARP
===
以太网帧发送时，必需指定 ethernet 地址。通过 IP 获取 ethernet 地址。
用法是在 ethernet 中不断地广播：
    1. 请求：若你为该 IP 的持有者，请广播你的 IP 和 MAC 地址。
    2. 应答：我的 IP 和 MAC 地址为。
注意，**收到请求和应答时，局域网的机器均会更新自己的 ARP 表**。

ARP 代理
---
启动 ARP 代理的路由器收到了 ARP 请求，如果是请求自己桥接的另一边的网络的主机，那么它会把自己的 MAC 地址应答过去。
这样可以让两个局域网的主机进行透明的跨局域网通信。

免费 ARP
---
机器启动时，可能会主动发送请求自己 IP 的 ARP 请求。这么做有以下目的：
    1. 排除有重复 IP 机器的可能；
    2. 以防自己 MAC 地址有变，让大家更新自己存储的地址。

RARP
===
RARP 是给自己用的。有的特殊机器没有存储自己的 IP 地址或指定从网络获取 IP 地址，就只能拿着 MAC 地址去问。
RARP 请求是广播，而应答由 **RARP 服务器** 由单播形式给出。RARP服务器就相当于负责分配 IP 地址的服务器。
可能会收到来自多个 RARP 服务器的应答。通常以先到的为准。

ICMP
===
ICMP 是一个 IP 层的协议（没有端口），虽然它是被包在 IP Datagram 里面的。
包含了 端口不可达 获取掩码 获取系统时间 Ping 等功能。
需要留意的是，Ping 的 -R 选项可以记录路由。

IP路由
===
路由过程还是比较 trivial 的，这里只提要注意的小点。
需要留意的是，在路由跳来跳去的时候，IP 头中的 IP 还是不变的。频繁修改用于转发的是 frame 中的 MAC 地址。
但是路由表中还是记录的 IP。正确的 MAC 地址利用 ARP 找到。

直接与间接路由
---
- 间接路由，有标记 G。此时发送的 Frame 中，IP 指向最终目的地，而 MAC 地址却指向你的网关。
- 直接路由，无标记 G。IP 和 MAC 均指向目的地。

路由表搜索步骤
---
1. 搜索表中主机地址。
2. 搜索表中网络地址。
3. 走默认路由项。

ICMP 不可达
---
当路由器没有转发项了（既没有直接间接路由，也没有默认路由。如走到头了或者其他相连的路由器挂了），将会向来源返回 ICMP 不可达错误。
如果发送目标主机没有开对应端口，也将发送这条消息。

ICMP 重定向
---
一个局域网里有多个路由器。如果其中一个路由器在做路由转发时，发现 Datagram 的来源接口居然和转发接口一样，那么则发送 ICMP 重定向错误。
上述情况说明了原消息本应发送的目标应该是同一局域网中的另一台路由器。收到错误的主机应对路由表进行相应修改（或创建新的表项）。
重定向消息可以帮助只有一个路由表不完善（例如只有一个默认路由，通常是刚初始化）的主机，逐渐丰富自己的路由表。
**该重定向错误只从发送给主机，路由器之间会使用其他学习路由表的算法**

ICMP 路由发现
---
让主机得知局域网中的路由器。不过仅仅依靠该协议，这些通告的路由器也只能按照优先级设为默认路由。
- 请求：主机启动时，可以向局域网中广播请求报文。
- 通告：路由器通告自己知道的局域网中的路由器IP。这些路由器拥有不同的优先级。路由器还会在随机时间向局域网自发发送通告。

动态路由
===
前述路由学习方式都是静态路由，也只有更新主机路由表的协议。这章介绍的是动态路由，且是路由器之间学习路由的行为。
本章算法都是用于局部自治系统的 Interior Gateway Protocol (IGP，内部网关协议)。连接各个局部系统的协议另算。

Routing Information Protocol (RIP) 距离向量算法
---
它被包在 UDP 中。看起来是一个应用层协议。
路由器维护路由项及对应跳数。所有路由器不断在 Ethernet 中广播自己的所有路由表项，并不断更新维护跳数最小的路由表。
跳数最大值16意味着不可达。（回复响应时）没有对应路由项或（维护自己的路由表时）发现某项路由过期，其跳数将会被设为16，并稍后删除。
如此做，失效的路由可以被传播（无论是通过回复响应时填16，还是自己再也不广播对应路由项）。

**缺陷**：收敛慢，易成环，适用网络小（最多15）.

Open Shortest Path First (OSPF) 链路状态算法
---
检查并向所有路由器提供相邻路由。收到的路由器自己维护拓扑结构。
OSPF 的特殊在于，它是存在于 IP 的上层，也就是和 TCP UDP 平级。

**优点**：收敛快；使用多播而非广播，更节省；**支持子网**。

Border Gateway Protocol (BGP) 距离向量算法
---
同相邻的路由器交换完整路由表和跳数。和 RIP 一个思路。
和 RIP 不同的点：
- 通告时不止告知跳数，还会通知路径。
- 使用 TCP 协议。因此利用 keepalive（这里间隔 30s）更迅速的发现失效的机器。

UDP
===

校验和
---
和 IP 协议只校验头部不同，TCP 和 UDP 需要校验整条协议，还需要包含伪首部（IP 头的一部分）。

IP 分片
---
由 IP 协议实施，根据经过链路的 MTU 进行分片，且到达最终目的地后再进行组装（哪怕中途经过不同网络进行了多次分片）。
失序重组也是由 IP 层根据总长度和片偏移完成。这些细节对于传输层协议来说是透明的。
**重传**： IP 丢失了一片，就需要重传整条消息。这点和 TCP 是不同的。原因是中途的路由器也会进行分片，根本无法做到只发送丢失的。**因此，上层协议会千方百计避免 IP 分片。**
**UDP的做法**：UDP 协议的实现通常限制每一个 Datagram 在**512B**。这远远小于以太网的限制（1500B），也小于前面提到的 **576B** 标准限制。如此来避免 IP 层分片。

UDP 队列
---
服务器程序通常使用 FIFO 队列来处理 UDP 消息。满了之后可以发送 **ICMP 源站抑制**错误，或不发送协议默默丢弃。

广播 多播
---
广播和多播只用于 UDP。广播目标分为一下几类：
- 255.255.255.255 受限广播，不会通过网关。
- 网络号 + 全为1主机号 网络广播，指向一个网络。
- 网络号 + 子网号 + 全为1主机号 子网广播，指向指定子网。
- 网络号 + 全为1子网号 + 全为1主机号 对该网络下所有子网进行广播。

**多播的好处** 广播给网络中无关的主机带来了额外的负荷。
**多播组** D类IP地址专门用于多播。后28位全为多播组号。主机自己指定自己加入某些多播组即可。其他细节（如路由），将在 IGMP 部分讨论。

IGMP
---
IGMP 协议维护多播组。多播通常只用于单个局域网。
- 多播路由器定时发送查询，维护多播组和主机地址的表。
- 主机需要以报告响应查询。
- 主机在一开始加入时也需要发送一次。
- 退出组时，需要做的仅仅是不再响应查询。

TCP概述
===
TCP 是一种可靠有连接的全双工**流**协议。链接根据 IP 端口 四元组来唯一确定。
其序列号由双方各自确定。TCP 可以有半连接状态。
发送 ACK 通常无代价，因为都是被其他协议顺带着捎过去的。
TCP 消息可以没有 payload，例如握手挥手的时候。

它做了以下工作：
- 分包
- 重传
- 确认
- 校验并期待收到重传
- 排序重组
- 去重
- 流量控制

它头部的表示为有以下几种：
- URG 紧急指针
- PSH 告知尽快将协议送到应用层
- RST 连接重置
- SYN
- ACK
- FIN

它需要维护以下定时器
- 重传
- persist
- keepalive
- TIME_WAIT

**TCP为什么慢**：需要慢启动。滑动窗口对速度有限制。而且如果中途丢了一个包，应用层就看不见其后所有的包。所以如果应用能容忍少量丢包，最好不要使用TCP。

**对于 ICMP 错误的处理**：TCP 无视前述 ICMP 不可达、重定向等错误。因为 ICMP 错误在这里被认为是可以短时间恢复的“软差错”。此时逻辑（超时等）全部按照 TCP 通用规则来，连接也继续保持。

TCP 连接的建立与终止
===

连接建立
---
双方在 SYN 时分别决定起始序号。同时初始化滑动窗口大小（默认4096），通告MSS
建立连接是超时且重传无响应，将会连接失败。
注意，在三次握手全部完成之前，应用层是感知不到的。

连接终止
---
双方分别关闭，可能处于半关闭状态。注意，最后发送消息的那方（即最后回复 ACK 的主动方）需要进入 TIME_WAIT 状态。

MSS
---
是排除头部以外的最大单个报文大小。
默认为 **536B** （算上头部576B，也是之前提过多次的长度）。当双方都在本地 Ethernet 时，将会定成 **1460B** （算上头部 1500B，是 Ethernet 的最大长度）
如上所述，MSS 的确定还是根据链路层来，思路和 UDP 一样，目的是避免 IP 做分片。

状态迁移图
---
**TODO 此处应有图**

TIME_WAIT 和 CLOSE_WAIT
---
- **CLOSE_WAIT** 
    是被动方接到 FIN，自己发送 FIN 之前处于的状态。此时连接处于半开状态。
- **TIME_WAIT** 
    是主动方收到被动方 FIN 并回复 ACK 中，持续等待 2MSL（通常为 2min * 2） 的状态。
    TIME_WAIT 的目的是保证被动方未收到 ACK 时，重发 FIN 可以收到正确的回复。但会占用额外的资源，且此时该端口不能使用。此时不能建立之前的四元组连接或监听该端口。
    为了避免负面影响，应尽量减少服务器主动断开链接，或开启 SO_REUSEADDR 选项。注意，SO_REUSEADDR 选项可以让服务器绑定该端口，但相同四元组连接仍然不能**主动**建立。不过在很多协议栈实现中，可以被动建立。

SO_REUSEPORT 和 SO_REUSEADDR
---
- **SO_REUSEPORT**
    可以重复监听一个地址的一个端口。
    如果监听一个ServerSocket并用多个epoll去监听同一个ServerSocket的fd，就会引起惊群。利用这个参数让多个ServerSocket监听同一个端口并不会引起惊群。这是因为内核做了分发，使用的类似哈希的方式，只分派给了一个serverSocket。
    这么做也避免了锁争用。当接受链接成为瓶颈时可以这么搞。

- **SO_REUSEADDR**
    可以监听同一个端口，只要指定的地址不完全一样，如真正的地址和0.0.0.0。
    同时，可以重复监听处于TIME_WAIT状态的端口。

RST
---
在以下场景使用：
- 向未监听的端口请求连接，则回复 RST。
- 强行关闭连接。此时对方不会管自己
- 确认是不是对方已经关闭链接而自己却不知道：此时向对方发送消息将会收到 RST，我就可以立马销毁链接了。

同时打开和同时关闭
---
- 同时打开将交换四次报文。此处应有图。原则是，只要我响应过了对方的 SYN，且也收到的对方的 ACK，那么链接就建立了。
- 同时关闭将交换四次报文。此处应有图。此时双方同时进入 TIME_WAIT 状态（因为都不知道对方有没有收到最后的 ACK）。

TCP 数据流交互
===
通过 ACK 收到的最后一个（无误的）序号 +1 来进行确认。注意双方用的序号互相独立。
ACK 不会立即回复，而是通常会等待 200ms 来便乘自己发的下一条消息。

Nagle 算法
---
为了增加效率，多个连续的小包会试图打包便乘。ACK 时回复最大的那个序号。
算法是，确保网络上未被确认的报文只有一个。如果出现了新的报文要发，那么只能等着便乘。
当然，打包的报文也像一般报文一样受到 MSS 和窗口的约束。
使用 TCP_NODELAY 来关闭该算法。

滑动窗口
---
尺寸是建立链接时通过**win字段**告知确定的，这点需要和拥塞窗口区分。接收方在回复 ACK 时需要告知剩余窗口大小（有可能确认收到，但窗口中的消息未被应用层消费）。
注意，这里的剩余大小是相对于当前 ACK 来的。

拥塞窗口和慢启动
---
若只有（相对较大的）固定滑动窗口，网络条件又不佳，可能会降低 TCP 的吞吐量。原因是进入到某些慢的（其实是带宽小的）网络的路由器没办法把所有数据报送进网络，造成缓存填满最终不得不丢弃包。
拥塞窗口和滑动窗口同时起作用。它的单位是未确认的报文数量，以 2 的指数从 1 开始每收到一个 ACK 增加一次。
理论上，最终窗口的大小与带宽*延迟成正比。

TCP 重传
===
通常，超时或对方发送三次重复的 ACK 后，就进行重传。重传的消息是不需要等待 ACK 的，发送方会继续做其他的事。

指数退避
---
TCP 遵循指数退避规则进行重传。时间为 1 3 6 12 ... 直至最长64s。重传共进行**12**次，最终会发送 RST 放弃链接。从首次丢失到最终放弃链接约为9分钟。
注意，这里的时间有随机偏移，在握手初始化定时器时计算的。
后续的重传将根据 RTT 调整，具体的算法老子实在是懒得看了。

ACK 规则
---
这里再强调一遍，回复的 ACK 是连续无误的消息的序号。例如若中间丢了一个，那么 ACK 将只会确认丢的那一个前面的。在这种情况，接收方可能发出序号重复的ACK。

拥塞控制
---
拥塞控制和前述拥塞窗口是两个独立的算法，不过通常它们会一起实现。流控中，拥塞控制和拥塞窗口是由发送方感知拥塞，而滑动窗口则由接收方控制。
该算法有以下两个数值：
- cwnd (拥塞窗口值) 初始为1个报文。
- ssthresh (拥塞控制值) 初始为65535B。
发送时未确认消息不能超过 cwnd 以及滑动窗口。

这两个数值如此进行维护：
- 一旦发生超时或重复 ACK，ssthresh 设置为 cwnd 和滑动窗口中最小值的一半。
- 一旦发生超时，cwnd 即可变回1。
- 一旦发生重复 ACK 重传，cwnd 设为 ssthresh + 3 * MSS。
- 当收到 ACK 时，增加数值，方式如下：
    1. 若 cwnd 更小，则为慢启动过程，直到 cwnd 回到一半滑动窗口大小。此时 cwnd 指数增长。
    2. 若 ssthresh 更小，则为拥塞控制过程。此时 cwnd 每次增加 1/cwnd，以保证每个 RTT 最多只增长1。
总体来说，这是一个以先前窗口大小的一半为基准，先快后慢的算法。且每次发生超时拥塞后都不得不从1开始。

快速重传和快速恢复
---
前述慢启动真的很蛋疼。引入快速恢复算法可以改善。
- 快速重传：当收到**3条**重复的 ACK 后就认为发生拥塞并进行重传。否则当作无事发生。也不需要等到超时。
- 快速恢复：在前述重传后，不需要从头开始慢启动，而是（根据前述拥塞控制规则）从窗口的一半多一点开始拥塞控制。

TCP keepalive
===
其实它不是 TCP 标准要求的功能。
通常规则为，若2小时没有交互，则间隔 75s 发送 10 条消息。
**需要记住，TCP 对于心跳保活支持非常有限，需要应用程序来完成（因为你发送心跳包后可以收到 RST，就知道需要关闭连接了）。**